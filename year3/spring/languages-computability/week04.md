# **Week 4: Pushdown Automata (PDAs)**
## Notes
---

### **1. Pushdown Automata**

### **What is a PDA?**

- A **PDA** is an extension of a **Finite State Automaton (FSA)** that includes a **stack** as additional memory.
- The stack allows the PDA to recognize **context-free languages (CFLs)**, which are more complex than regular languages.

### **Key Components of a PDA**:

- **States**: Like an FSA, a PDA has states.
- **Input Tape**: The PDA reads input symbols from the input tape.
- **Stack**: The PDA can push symbols onto the stack or pop symbols from the stack.
- **Transitions**: Transitions are based on the current state, the input symbol, and the **top symbol** on the stack.

### **Example PDA**:

- For the language {0n1n∣n≥0}{0*n*1*n*∣*n*≥0}:
    - Push `0`s onto the stack for each `0` in the input.
    - Pop `0`s from the stack for each `1` in the input.
    - Accept if the stack is empty when the input ends.

---

### **2. Formal Definition of PDAs**

### **PDA as a 6-tuple**

- A **PDA** is defined as a 6-tuple M=(Q,Σ,Γ,δ,q0,F)*M*=(*Q*,Σ,Γ,*δ*,*q*0​,*F*):
    - Q*Q*: Finite set of states.
    - ΣΣ: Input alphabet.
    - ΓΓ: Stack alphabet.
    - δ*δ*: Transition function Q×Σϵ×Γϵ→P(Q×Γϵ)*Q*×Σ*ϵ*​×Γ*ϵ*​→*P*(*Q*×Γ*ϵ*​).
    - q0*q*0​: Start state.
    - F*F*: Set of accept states.

### **Transition Function**:

- The transition function δ*δ* takes:
    - The current state q∈Q*q*∈*Q*.
    - The current input symbol a∈Σϵ*a*∈Σ*ϵ*​ (where Σϵ=Σ∪{ϵ}Σ*ϵ*​=Σ∪{*ϵ*}).
    - The top symbol on the stack b∈Γϵ*b*∈Γ*ϵ*​ (where Γϵ=Γ∪{ϵ}Γ*ϵ*​=Γ∪{*ϵ*}).
- It returns a set of pairs (q′,b′)(*q*′,*b*′), where:
    - q′*q*′ is the next state.
    - b′*b*′ is the symbol to be pushed onto the stack (or ϵ*ϵ* if no symbol is pushed).

---

### **3. PDA Examples**

### **Example 1: PDA for {0n1n∣n≥0}{0*n*1*n*∣*n*≥0}**

- **States**: `q0`, `q1`, `q2`.
- **Transitions**:
    - From `q0`, on `0`, push `0` onto the stack and stay in `q0`.
    - From `q0`, on `1`, pop `0` from the stack and move to `q1`.
    - From `q1`, on `1`, pop `0` from the stack and stay in `q1`.
    - From `q1`, on empty input and empty stack, move to `q2` (accepting state).
- **Execution Example**:
    - Input: `0011`
        - Start in `q0` with an empty stack.
        - Read `0`, push `0` onto the stack.
        - Read `0`, push another `0` onto the stack.
        - Read `1`, pop `0` from the stack and move to `q1`.
        - Read `1`, pop `0` from the stack and stay in `q1`.
        - Since the stack is empty and the input is fully read, move to `q2` (accepting state).

### **Example 2: PDA for {aibjck∣i=j or i=k}{*aibjck*∣*i*=*j* or *i*=*k*}**

- **Key Idea**: The PDA first reads and pushes `a`s onto the stack.
- It then matches the `a`s with either the `b`s or the `c`s.
- **Nondeterminism** is essential here: the PDA "guesses" whether to match `a`s with `b`s or `c`s.

### **Example 3: PDA for {wwR∣w∈{0,1}∗}{*wwR*∣*w*∈{0,1}∗}**

- **Key Idea**: The PDA pushes symbols onto the stack until it nondeterministically guesses the middle of the string.
- It then pops symbols from the stack and compares them with the input symbols.

---

### **4. Equivalence of CFGs and PDAs**

### **Theorem**:

- A language is **context-free** if and only if some PDA recognizes it.
- This means that **CFGs** and **PDAs** are equivalent in expressive power.

### **Proof**:

- **CFG to PDA**: Given a CFG, we can construct a PDA that recognizes the same language.
- **PDA to CFG**: Given a PDA, we can construct a CFG that generates the same language.

---

### **5. Transforming CFGs into PDAs**

### **Key Idea**:

- The transitions in the PDA "encode" the productions in the CFG.
- The stack holds the non-terminals in the RHS of productions that have not been used in the derivation.

### **Steps**:

1. Define the stack alphabet Γp=N∪T∪{$}Γ*p*​=*N*∪*T*∪{$}.
2. Define the input alphabet Σp=TΣ*p*​=*T*.
3. Set Qp={qp,qloop,qaccept}∪E*Qp*​={*qp*​,*qloop*​,*qaccept*​}∪*E*.
4. Add transitions for each production rule.

### **Example**:

- For the CFG S→aSb∣ϵ*S*→*aSb*∣*ϵ*:
    - The PDA pushes `a` and `S` onto the stack for the production S→aSb*S*→*aSb*.
    - The PDA pops `S` from the stack for the production S→ϵ*S*→*ϵ*.

---

### **6. Transforming PDAs into CFGs**

### **Key Idea**:

- Each non-terminal Apq*Apq*​ generates all strings that take the PDA from state p*p* to state q*q* with an empty stack.

### **Steps**:

1. Convert the PDA into an equivalent PDA with a single accept state and empty stack.
2. Define non-terminals Apq*Apq*​ for each pair of states p,q*p*,*q*.
3. Add rules for transitions and stack operations.

---

### **7. Non-Context-Free Languages**

### **What is a Non-Context-Free Language?**

- Some languages cannot be generated by any CFG or recognized by any PDA.
- These languages require more powerful computational models, like **Turing Machines**.

### **Examples of Non-Context-Free Languages**:

1. **Language with Equal Number of `a`s, `b`s, and `c`s**:
    - {anbncn∣n≥0}{*anbncn*∣*n*≥0}
    - This language cannot be recognized by a PDA because it requires counting and matching three different symbols.
2. **Language with Repeated Substrings**:
    - {ww∣w∈{0,1}∗}{*ww*∣*w*∈{0,1}∗}
    - This language cannot be recognized by a PDA because it requires remembering the first half of the string to compare it with the second half.

### **Pumping Lemma for CFLs**:

- A tool used to prove that a language is **not context-free**.
- **Idea**: If a language is context-free, then any sufficiently long string in the language can be "pumped" (repeated) to generate new strings that are also in the language.
- If a language **fails** the pumping lemma, it is **not context-free**.

---

### **8. Deterministic Context-Free Languages (DCFLs)**

### **What is a DCFL?**

- A **DCFL** is a subset of context-free languages recognized by **deterministic PDAs (DPDAs)**.
- **DPDAs** have a single transition from each state, making them suitable for parsing programming languages.

### **Example**:

- The language {anbn∣n≥0}{*anbn*∣*n*≥0} is a DCFL because it can be recognized by a deterministic PDA.

---

### **Summary**

### **Pushdown Automata (PDAs)**:

- **What is it?** A PDA is an extension of an FSA that includes a stack, allowing it to recognize context-free languages.
- **Example**: A PDA that recognizes the language {0n1n∣n≥0}{0*n*1*n*∣*n*≥0}.

### **Equivalence of CFGs and PDAs**:

- CFGs and PDAs are equivalent in expressive power.

### **Non-Context-Free Languages**:

- Some languages cannot be recognized by PDAs or generated by CFGs.
