# Week 3: Context-free Languages
## Notes
---

### 1. Grammars
- **Grammars** are used to define languages.
- A **grammar** is a 4-tuple \( G = (N, T, S, P) \):
  - \( N \): Non-terminals (finite alphabet).
  - \( T \): Terminals (finite alphabet).
  - \( S \): Start symbol (\( S \in N \)).
  - \( P \): Productions (rules of the form \( \alpha \rightarrow \beta \)).

#### Example Grammar
- For the language \( L = \{a^n b^n : n \geq 0\} \):
  - \( N = \{X\} \)
  - \( T = \{a, b\} \)
  - \( S = X \)
  - \( P = \{X \rightarrow \epsilon, X \rightarrow aXb\} \)

### 2. Context-free Grammars (CFGs)
- A **CFG** is a grammar where all productions are of the form \( \alpha \rightarrow \beta \), where \( \alpha \in N \) (a single non-terminal).
- **Context-free** because the left-hand side is a single non-terminal, and the rule can be applied regardless of the context.

#### Example CFG
- For algebraic expressions:
  - \( G = (\{S\}, \{a, +, *, (,)\}, S, \{S \rightarrow S + S | S * S | (S) | a\}) \)

### 3. Regular Grammars
- A **regular grammar** is a CFG where each production is of the form:
  - \( A \rightarrow t \) or \( A \rightarrow tB \) or \( A \rightarrow \epsilon \), where \( A, B \in N \) and \( t \in T \).
- Regular grammars generate **regular languages**.

#### Example Regular Grammar
- \( S \rightarrow aA \), \( S \rightarrow bB \), \( A \rightarrow aS \), \( A \rightarrow a \), \( B \rightarrow bS \), \( B \rightarrow b \).

### 4. Applications & Constructing Grammars
- **Applications**:
  - Natural language processing.
  - Formalizing designs and specifications.
  - Pattern recognition.
- **Constructing Grammars**:
  - For languages like \( (a \circ b)^n \circ c^m \circ (a \circ b)^n \), we need rules for sequencing, bracketing, and nesting.

### 5. Parsing
- **Parsing** is the process of determining whether a string belongs to a language defined by a grammar.
- **Derivation trees** are used to represent the structure of the derivation.

### 6. Ambiguity
- A grammar is **ambiguous** if a string has more than one derivation tree.
- **Example**: The grammar \( S \rightarrow S + S | S * S | (S) | a \) is ambiguous for the string \( a + a * a \).

### 7. Chomsky Normal Form (CNF)
- A CFG is in **CNF** if every rule is of the form:
  - \( A \rightarrow BC \) or \( A \rightarrow a \), where \( A, B, C \in N \) and \( a \in T \).
- **Theorem**: Any context-free language can be generated by a CFG in CNF.

## Summary
Pushdown Automata (PDAs):
- What is it? A PDA is an extension of an FSA that includes a stack, which provides additional memory. The stack allows the PDA to recognize context-free languages (CFLs), which are more complex than regular languages.

- Example: Consider a PDA that recognizes the language {0^n 1^n | n â‰¥ 0} (strings with an equal number of 0s followed by 1s).

  - States: Three states: q0, q1, and q2.

  - Transitions:

    - From `q0`, on `0`, push `0` onto the stack and stay in `q0`.

    - From `q0`, on `1`, pop `0` from the stack and move to `q1`.

    - From `q1`, on `1`, pop `0` from the stack and stay in `q1`.

    - From `q1`, on empty input and empty stack, move to `q2` (accepting state).

  - Accept State: `q2`.

  If the input string is `0011`, the PDA will:

  - Start in `q0` with an empty stack.

  - Read `0`, push `0` onto the stack.

  - Read `0`, push another `0` onto the stack.

  - Read `1`, pop `0` from the stack and move to `q1`.

  - Read `1`, pop `0` from the stack and stay in `q1`.

  - Since the stack is empty and the input is fully read, move to `q2` (accepting state).
